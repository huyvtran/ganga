import { getCell, setCell } from '../base/index';
import { DataManager, Query, DataUtil, Deferred } from '@syncfusion/ej2-data';
import { getCellIndexes, getIndexesFromAddress, getColumnHeaderText, getSwapRange, getRangeAddress } from '../common/index';
import { initiateSort } from '../common/event';
import { isNullOrUndefined } from '@syncfusion/ej2-base';
/**
 * The `WorkbookSort` module is used to handle sort action in Spreadsheet.
 */
var WorkbookSort = /** @class */ (function () {
    /**
     * Constructor for WorkbookSort module.
     */
    function WorkbookSort(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the sort module.
     */
    WorkbookSort.prototype.destroy = function () {
        this.removeEventListener();
        this.parent = null;
    };
    WorkbookSort.prototype.addEventListener = function () {
        this.parent.on(initiateSort, this.initiateSortHandler, this);
    };
    WorkbookSort.prototype.removeEventListener = function () {
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateSort, this.initiateSortHandler);
        }
    };
    /**
     * Sorts range of cells in the sheet.
     * @param args - arguments for sorting.
     */
    WorkbookSort.prototype.initiateSortHandler = function (eventArgs) {
        var _this = this;
        var args = eventArgs.args;
        var deferred = new Deferred();
        var sheet = this.parent.getActiveSheet();
        var range = getSwapRange(getIndexesFromAddress(args.range));
        var sortOptions = args.sortOptions || { sortDescriptors: {}, containsHeader: true };
        var isSingleCell = false;
        eventArgs.promise = deferred.promise;
        if (range[0] > sheet.usedRange.rowIndex - 1 || range[1] > sheet.usedRange.colIndex) {
            deferred.reject('Select a cell or range inside the used range and try again.');
            return;
        }
        var containsHeader = sortOptions.containsHeader;
        if (range[0] === range[2] && (range[2] - range[0]) === 0) { //if selected range is a single cell 
            range[0] = 0;
            range[1] = 0;
            range[2] = sheet.usedRange.rowIndex - 1;
            range[3] = sheet.usedRange.colIndex;
            isSingleCell = true;
            containsHeader = isNullOrUndefined(sortOptions.containsHeader) ? true : sortOptions.containsHeader;
        }
        var sRIdx = containsHeader ? range[0] + 1 : range[0];
        if ((isNullOrUndefined(args.sortOptions) || isNullOrUndefined(args.sortOptions.containsHeader)) && !isSingleCell) {
            if (!isNullOrUndefined(getCell(range[0], range[1], sheet)) && !isNullOrUndefined(getCell(range[0] + 1, range[1], sheet))) {
                if (typeof getCell(range[0], range[1], sheet).value === typeof getCell(range[0] + 1, range[1], sheet).value) {
                    sRIdx = range[0];
                    containsHeader = false;
                }
                else {
                    sRIdx = range[0] + 1;
                    containsHeader = true;
                }
            }
        }
        var sCIdx;
        var eCIdx;
        var cell = getCellIndexes(sheet.activeCell);
        var header = 'Column ' + getColumnHeaderText(cell[1] + 1);
        var sortDescriptors = sortOptions.sortDescriptors;
        this.getDataRange(range, sheet, containsHeader).then(function (jsonData) {
            var dataManager = new DataManager(jsonData);
            var query = new Query();
            if (Array.isArray(sortDescriptors)) { //multi-column sorting.
                if (!sortDescriptors || sortDescriptors.length === 0) {
                    sortDescriptors = [{ field: header }];
                }
                for (var length_1 = sortDescriptors.length, i = length_1 - 1; i > -1; i--) {
                    if (!sortDescriptors[length_1 - 1].field) {
                        sortDescriptors[length_1 - 1].field = header;
                    }
                    if (!sortDescriptors[i].field) {
                        continue;
                    }
                    var comparerFn = sortDescriptors[i].sortComparer || _this.sortComparer.bind(_this, sortDescriptors[i]);
                    query.sortBy(sortDescriptors[i].field, comparerFn);
                }
            }
            else { //single column sorting.
                if (!sortDescriptors) {
                    sortDescriptors = { field: header };
                }
                if (!sortDescriptors.field) {
                    sortDescriptors.field = header;
                }
                var comparerFn = sortDescriptors.sortComparer || _this.sortComparer.bind(_this, sortDescriptors);
                query.sortBy(sortDescriptors.field, comparerFn);
            }
            dataManager.executeQuery(query).then(function (e) {
                var colName;
                var cell = {};
                Array.prototype.forEach.call(e.result, function (data) {
                    sCIdx = range[1];
                    eCIdx = range[3];
                    for (sCIdx; sCIdx <= eCIdx; sCIdx++) {
                        colName = 'Column ' + getColumnHeaderText(sCIdx + 1);
                        cell = data[colName];
                        setCell(sRIdx, sCIdx, sheet, cell);
                    }
                    sRIdx++;
                });
                var eventArgs = { range: getRangeAddress(range), sortOptions: args.sortOptions };
                deferred.resolve(eventArgs);
            });
        });
    };
    /**
     * Compares the two cells for sorting.
     * @param sortDescriptor - protocol for sorting.
     * @param x - first cell
     * @param y - second cell
     */
    WorkbookSort.prototype.sortComparer = function (sortDescriptor, x, y) {
        //fix - when x and y values are empty, cells should not be swapped.
        if (!(x ? x.value : x) && !(y ? y.value : y)) {
            return -1; // Need to remove this condition once this is handled in fnSort()
        }
        var direction = sortDescriptor.order || '';
        var comparer = DataUtil.fnSort(direction);
        return comparer(x ? x.value : x, y ? y.value : y);
    };
    ;
    /**
     * Converts the range of cells to json data.
     * @param range - range array
     * @param sheet - model of the sheet
     */
    WorkbookSort.prototype.getDataRange = function (range, sheet, containsHeader) {
        var jsonData = [];
        var sRIdx = containsHeader ? range[0] + 1 : range[0];
        var eRIdx = range[2];
        var sCIdx;
        var eCIdx;
        var rowNum = 0;
        var sheetEx = sheet;
        var option = {
            sheet: sheetEx, indexes: [0, 0, sheet.rowCount - 1, sheet.colCount - 1], promise: new Promise(function (resolve, reject) { resolve((function () { })()); })
        };
        if (sheetEx.isLocalData && (range[0] === 0 || range[0] === 1) && range[2] === (sheet.rowCount - 1)) {
            this.parent.notify('updateSheetFromDataSource', option);
        }
        return option.promise.then(function () {
            for (sRIdx; sRIdx <= eRIdx; sRIdx++) {
                sCIdx = range[1];
                eCIdx = range[3];
                var cells = {};
                var colName = '';
                for (sCIdx; sCIdx <= eCIdx; sCIdx++) {
                    colName = 'Column ' + getColumnHeaderText(sCIdx + 1);
                    cells[colName] = getCell(sRIdx, sCIdx, sheet);
                    jsonData[rowNum.toString()] = cells;
                }
                rowNum++;
            }
            return jsonData;
        });
    };
    /**
     * Gets the module name.
     * @returns string
     */
    WorkbookSort.prototype.getModuleName = function () {
        return 'workbookSort';
    };
    return WorkbookSort;
}());
export { WorkbookSort };
